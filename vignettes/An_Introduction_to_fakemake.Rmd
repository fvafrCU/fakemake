---
title: "An Introduction to *fakemake*"
author: "Andreas Dominik Cullmann"
date: 2017-11-06, 22:29:47
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{An Introduction to fakemake }
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
references:
- id: powers2002
  title: Unix Power Tools
  author:
  - family: Powers
    given: Shelley
  - family: Peek
    given: Jerry
  - family: "O'Reilly"
    given: Tim
  - family: Loudikes
    given: Mike
  ISBN: 0-596-00330-7
  publisher: "O'Reilly & Associates"
  type: book
  issued:
    year: 2002
---

# Why Mock the Unix Make Utility?
There are
[many](https://en.wikipedia.org/wiki/List_of_build_automation_software)
[build systems](https://en.wikipedia.org/wiki/Build_automation),
and more uses for build systems [see @powers2002, sections 11.10 and 11.11].

I have been using the
[unix make utility](https://en.wikipedia.org/wiki/Make_(software)) when
developing R packages since 2012. But sometimes I get caught on a machine where
*make* is not available and where I am not entitled to install it.
This is why I wrote *fakemake*: to build an R package conditionally on the
modification times of (file) dependencies without having to rely on external
software.
If you have any proper build system at hand: stick to it, do not use *fakemake*.

# withr and knitr
Throughout this vignette I use  **R**'s temporary directory, often by using 
`withr::with_dir(tempdir(), ...)`. Because this is a vignette and the codes are
examples. In real life, we would skip the temporary directory stuff.

Vignettes are built using *knitr*, which itself uses `sink()`. As `sink()` is one
central to *fakemake* for redirecting to output to files in the make chain, it
will have to disable `knitr`'s here and there. Don't worry, it's just because 
*knitr* and *fakemake* both want to use `sink()` exclusively.

# Makelists
A makelist is the *fakemake*`s representation of a Makefile.
It's just a list of lists.
Look at the minimal makelist provided by *fakemake*:
```{r}
str(fakemake::provide_make_list("minimal", clean_sink = TRUE))
```
Each sublist represents a Makefile's target rule and has several items:
at least a *target* and either *code* or *prerequisites*, possibly both.
This makelist would still be a Makefile's valid representation if target rule #3
with target "a1.Rout" had no (or an empty) *code* entry.

Other possible target rule entries are:

- *alias*: An alias to target that would be easier to remember and/or type.
- *sink*: By default, all output of the *code* entry is dumped (well, with
                                                                **R**'s
                                                                *sink* function)
  into a file with the mame given by *target*. If *target* should be created by
  the *code* you will want to redirect the output into *sink*.
- *.PHONY*: If set to TRUE, the target is rebuilt unconditionally every time the
  target is hit (trying to mock GNU make's .PHONY-extension.


# A Minimal Example
Suppose we would have a minimal makelist:
```{r}
ml <- fakemake::provide_make_list("minimal", clean_sink = TRUE)
```

## Building and Rebuilding
Now build the "all.Rout" *target*:

```{r}
withr::with_dir(tempdir(), print(fakemake::make("all.Rout", ml)))
```
We can see the files created:
```{r}
show_file_mtime <- function(files = list.files(tempdir(), full.names = TRUE,
                                               pattern = "^.*\\.Rout")) {
    return(file.info(files)["mtime"])
}
show_file_mtime()
```
If we wait for a second and rerun the build process, we get:

```{r}
# ensure the modification time would change if the files were recreated
Sys.sleep(1)
withr::with_dir(tempdir(), print(fakemake::make("all.Rout", ml)))
show_file_mtime()
```
Nothing changed. Good.
Now, we change one file down the build chain:

```{r}
fakemake::touch(file.path(tempdir(), "b1.Rout"))
withr::with_dir(tempdir(), print(fakemake::make("all.Rout", ml)))
show_file_mtime()
```

Since a1.Rout depends on b1.Rout and all.Rout depends on a1.Rout, these targets
get rebuilt while a2.Rout stays untouched.

Had we touched a1.Rout, b1.Rout would not have been rebuilt:
```{r, echo = FALSE}
# touch should do the job...
Sys.sleep(1)
```

``` {r}
fakemake::touch(file.path(tempdir(), "a1.Rout"))
withr::with_dir(tempdir(), print(fakemake::make("all.Rout", ml)))
show_file_mtime()
```

## Forcing The Build
If you set the force option, you can force the target and all its prerequisites
down the build chain to be built:
``` {r}
withr::with_dir(tempdir(), print(fakemake::make("all.Rout", ml, force = TRUE)))
```


## Using aliases
If you find a target rule's *target* too hard to type, you can use an alias:
``` {r}
i <- which(sapply(ml, "[[", "target") == "all.Rout")
ml[[i]]["alias"] <- "all"
withr::with_dir(tempdir(), print(fakemake::make("all", ml, force = TRUE)))
```
This is pointless here, but *target*s might be files down a
directory tree like 'log/testthat.Rout' when building **R** packages.

## Diverting Output
Target rule b1 dumps its output to b1.Rout:
``` {r}
cat(readLines(file.path(tempdir(), "b1.Rout")), sep = "\n")
```
Suppose it would programmatically create the target:
``` {r}
i <- which(sapply(ml, "[[", "target") == "b1.Rout")
ml[[i]]["code"]  <- paste(ml[[i]]["code"],
                      "cat('hello, world\n', file = \"b1.Rout\")",
                      "print(\"foobar\")",
                      sep = ";")
withr::with_dir(tempdir(), print(fakemake::make("b1.Rout", ml, force = TRUE)))
cat(readLines(file.path(tempdir(), "b1.Rout")), sep = "\n")
```
You end up with a broken target file, so you need to add a *sink*:
``` {r}
ml[[i]]["sink"] <- "b1.txt"
withr::with_dir(tempdir(), print(fakemake::make("b1.Rout", ml, force = TRUE)))
```
Now you get what you wanted:
``` {r}
cat(readLines(file.path(tempdir(), "b1.Rout")), sep = "\n")
cat(readLines(file.path(tempdir(), "b1.txt")), sep = "\n")
```

## No Code Targets
Rule a1 has *code*
``` {r}
i <- which(sapply(ml, "[[", "target") == "a1.Rout")
ml[[i]]["code"]
```
that prints "a1" into "a1.Rout":
``` {r}
cat(readLines(file.path(tempdir(), "a1.Rout")), sep = "\n")
```

If we remove that code and its output file and rerun
``` {r}
ml[[i]]["code"]  <- NULL
withr::with_dir(tempdir(), print(fakemake::make("a1.Rout", ml, force = TRUE)))
```
the file is still created but empty:
``` {r}
file.size(file.path(tempdir(), "a1.Rout"))
```

## Phony Targets
As you have seen, you can temporarily force a build.
You may set a target to be .PHONY which forces it (but not its prerequisites) to
be built:
``` {r}
ml[[i]][".PHONY"]  <- TRUE
withr::with_dir(tempdir(), print(fakemake::make("a1.Rout", ml)))
```

# Building **R** Packages Using *Fakemake*

We will now look a *fakemake*'s main purpose: building packages.
First, we need to create a sample package.

## Creating the Package
First, we create a package skeleton:
``` {r, results = "hide", message = FALSE}
pkg_path <- file.path(tempdir(), "fakepack")
unlink(pkg_path, force = TRUE, recursive = TRUE)
devtools::create(pkg_path)
```

We add a minimal R code file and a log directory:

``` {r}
file.copy(system.file("templates", "throw.R", package = "fakemake"),
          file.path(pkg_path, "R"))
dir.create(file.path(pkg_path, "log"))
```

This package does not make any sense. It is just a minimal working example 
(in the sense that it passes `R CMD build` and a simple `R CMD check`). 
It does not provide any functionality apart from a single internal function
that is not exported via the package's NAMESPACE. 
It is just there to exemplify the usage of *fakemake*.


## Setting up the Makelist
Then we get a package makelist from *fakemake*:

``` {r}
ml <- fakemake::provide_make_list("package")
```

This list is a bit more complex than the minimal example above, so we visualize
it:
``` {r,fig.width = 6.5, fig.height = 6.5}
withr::with_dir(pkg_path, fakemake::visualize(ml))
```

Obviously the tarball depends on many files and the only target that's no other
target's prerequisite is "log/check.Rout".
If you are more into hierarchical depictions, you can use the terminal target as
root:

``` {r,fig.width = 6.5, fig.height = 6.5}
withr::with_dir(pkg_path, fakemake::visualize(ml, root = "log/check.Rout"))
```

But then you might be interested in
[this python program](https://github.com/lindenb/makefile2graph),
I regularly use it to visualize complex Makefiles.


## Building the Package
Now we build and check the package in one go:

``` {r, warning = FALSE, message = FALSE}
withr::with_dir(pkg_path, print(fakemake::make("check", ml)))
```

We see the created in the log directory correspond to the names given by *make*:

``` {r}
list.files(file.path(pkg_path, "log"))
```

and we can take a look at one:
``` {r}
cat(readLines(file.path(pkg_path, "log", "roxygen2.Rout")), sep = "\n")
```


Rebuilding the package does not do anything (NULL is returned instead of a the
                                             names of targets above), you save
quite some CPU time:

``` {r}
system.time(suppressMessages(withr::with_dir(pkg_path,
                                             print(fakemake::make("check",
                                                                  ml)))))
```

## Changing Files and Rebulding the Package
Let us take a look at our testing coverage:

``` {r}
cat(readLines(file.path(pkg_path, "log", "covr.Rout")), sep = "\n")
```

Well, poor. So we add a test file:

``` {r}
dir.create(file.path(pkg_path, "tests", "testthat"), recursive = TRUE)
file.copy(system.file("templates", "testthat.R", package = "fakemake"),
          file.path(pkg_path, "tests"))
file.copy(system.file("templates", "test-throw.R", package = "fakemake"),
          file.path(pkg_path, "tests", "testthat"))

```

Now we check the package again:
``` {r, warning = FALSE, message = FALSE}
withr::with_dir(pkg_path, print(fakemake::make("check", ml)))
```

We see that most of the build chain is rerun, except *roxygenising*, since the
files under "tests/" are not prerequisites to *log/royxgen2.Rout*.
Ah, and the test coverage is improved:
``` {r}
cat(readLines(file.path(pkg_path, "log", "covr.Rout")), sep = "\n")
```

# References
