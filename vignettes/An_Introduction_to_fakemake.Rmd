---
title: "An Introduction to *fakemake*"
author: "Andreas Dominik Cullmann"
date: 2017-11-03, 23:53:05
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{An Introduction to fakemake }
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
references:
- id: powers2002
  title: Unix Power Tools
  author:
  - family: Powers
    given: Shelley
  - family: Peek
    given: Jerry
  - family: "O'Reilly"
    given: Tim
  - family: Loudikes
    given: Mike
  ISBN: 0-596-00330-7
  publisher: "O'Reilly & Associates"
  type: book
  issued:
    year: 2002
---

# Mock the Unix Make Utility
There are
[many](https://en.wikipedia.org/wiki/List_of_build_automation_software)
[build systems](https://en.wikipedia.org/wiki/Build_automation),
and more uses for build systems [see @powers2002, sections 11.10 and 11.11].

I have been using the
[unix make utility](https://en.wikipedia.org/wiki/Make_(software)) when
developing R packages since 2012. But sometimes I get caught on a machine where
*make* is not available and where I am not entitled to install it.
This is why I wrote *fakemake*: to build an R package conditionally on the
modification times of (file) dependencies without having to rely on external
software.
If you have any proper build system at hand: stick to it, do not use *fakemake*.

# Makelists
A makelist is the *fakemake*`s representation of a Makefile.
It's just a list of lists.
Look at the minimal makelist provided with *fakemake*:
```{r}
str(fakemake::provide_make_list("minimal", clean_sink = TRUE))
```
Each sublist represents a Makefile's target rule and has several items:
at least a *target* and either *code* or *prerequisites*, possibly both.
This makelist would still be a Makefile's valid representation if target rule #3
with target "a1.Rout" had no (or an empty) *code* entry.

Other possible target rule entries are:

- *alias*: An alias to target that would be easier to remember and/or type.
- *sink*: By default, all output of the *code* entry is dumped (well, with
                                                                **R**'s
                                                                *sink* function)
  into a file with the mame given by *target*. If *target* should be created by
  the *code* you will want to redirect the output into *sink*.
- *.PHONY*: If set to TRUE, the target is rebuilt unconditionally every time the
  target is hit (trying to mock GNU make's .PHONY-extension.


# A Minimal Example
Suppose we would have a minimal makelist:
```{r}
ml <- fakemake::provide_make_list("minimal", clean_sink = TRUE)
```

## Building and Rebuilding
Now we would use **R**'s temporary directory to build the "all" *target* in this
makelist:

```{r}
withr::with_dir(tempdir(), print(fakemake::make("all.Rout", ml)))
```
We can see the files created:
```{r}
show_file_mtime <- function(files = list.files(tempdir(), full.names = TRUE,
                                               pattern = "^.*\\.Rout")) {
    return(file.info(files)["mtime"])
}
show_file_mtime()
```
If we wait for a second and rerun the build process, we get:

```{r}
# ensure the modification time would change if the files were recreated
Sys.sleep(1)
withr::with_dir(tempdir(), print(fakemake::make("all.Rout", ml)))
show_file_mtime()
```
Nothing changed. Good.
Now, we change one file down the build chain:

```{r}
fakemake::touch(file.path(tempdir(), "b1.Rout"))
withr::with_dir(tempdir(), print(fakemake::make("all.Rout", ml)))
show_file_mtime()
```

Since a1.Rout depends on b1.Rout and all.Rout depends on a1.Rout, these targets
get rebuilt while a2.Rout stays untouched.

Had we touched a1.Rout, b1.Rout would not have been rebuilt:
```{r, echo = FALSE}
# touch should do the job...
Sys.sleep(1)
```

``` {r}
fakemake::touch(file.path(tempdir(), "a1.Rout"))
withr::with_dir(tempdir(), print(fakemake::make("all.Rout", ml)))
show_file_mtime()
```

## Forcing The Build
If you set the force option, you can force the target and all its prerequisites
down the build chain to be built:
``` {r}
withr::with_dir(tempdir(), print(fakemake::make("all.Rout", ml, force = TRUE)))
```


## Using aliases
If you find a target rule's *target* too hard to type, you can use an alias:
``` {r}
i <- which(sapply(ml, "[[", "target") == "all.Rout")
ml[[i]]["alias"] <- "all"
withr::with_dir(tempdir(), print(fakemake::make("all", ml, force = TRUE)))
```
This is pointless here, but *target*s might be files down a
directory tree like 'log/testthat.Rout' when building **R** packages.

## Diverting Output
Target rule b1 dumps its output to b1.Rout:
``` {r}
file.show(file.path(tempdir(), "b1.Rout"), pager = "cat")
```
Suppose it would programmatically create the target:
``` {r}
i <- which(sapply(ml, "[[", "target") == "b1.Rout")
ml[[i]]["code"]  <- paste(ml[[i]]["code"],
                      "cat('hello, world', file = \"b1.Rout\")",
                      "print(\"foobar\")",
                      sep = ";")
withr::with_dir(tempdir(), print(fakemake::make("b1.Rout", ml, force = TRUE)))
file.show(file.path(tempdir(), "b1.Rout"), pager = "cat")
```
You end up with a broken target file, so you need to add a *sink*:
``` {r}
ml[[i]]["sink"] <- "b1.txt"
withr::with_dir(tempdir(), print(fakemake::make("b1.Rout", ml, force = TRUE)))
file.show(file.path(tempdir(), "b1.Rout"), pager = "cat")
file.show(file.path(tempdir(), "b1.txt"), pager = "cat")
```

## No Code Targets
Rule a1 has *code*
``` {r}
i <- which(sapply(ml, "[[", "target") == "a1.Rout")
ml[[i]]["code"]
```
that prints "a1" into "a1.Rout":
``` {r}
file.show(file.path(tempdir(), "a1.Rout"), pager = "cat")
```

If we remove that code and its output file and rerun
``` {r}
ml[[i]]["code"]  <- NULL
withr::with_dir(tempdir(), print(fakemake::make("a1.Rout", ml, force = TRUE)))
```
the file is still created but empty:
``` {r}
file.size(file.path(tempdir(), "a1.Rout"))
```

## Phony Targets
As you have seen, you can temporarily force a build.
You may set a target to be .PHONY which forces it (but not its prerequisites) to
be built:
``` {r}
ml[[i]][".PHONY"]  <- TRUE
withr::with_dir(tempdir(), print(fakemake::make("a1.Rout", ml)))
```

# Building **R** Packages

First, we create a package skeleton:
``` {r}
pkg_path <- file.path(tempdir(), "fakepack")
unlink(pkg_path, force = TRUE, recursive = TRUE)
devtools::create(pkg_path)
file.copy(system.file("templates", "throw.R", package = "fakemake"),
          file.path(pkg_path, "R"))
dir.create(file.path(pkg_path, "log"))
```
Then we get a package makelist:
``` {r}
str(ml <- fakemake::provide_make_list("package"))
```
This is a more complex thing, we can take a glimpse:
``` {r,fig.width = 7, fig.height = 7}
withr::with_dir(pkg_path, plot(fakemake::makelist2igraph(ml)))
```

Now we build and check the package in one go:

``` {r}
withr::with_dir(pkg_path, print(fakemake::make("check", ml)))
list.files(file.path(pkg_path, "log"))
```
Rebuilding the package does not consume CPU time:
``` {r}
system.time(suppressMessages(withr::with_dir(pkg_path,
                                             print(fakemake::make("check",
                                                                  ml)))))
```
Let us take a look at our testing coverage:
``` {r}
file.show(file.path(pkg_path, "log", "covr.Rout"), pager = "cat")
```
Well, poor. So now we add test files:
``` {r}
dir.create(file.path(pkg_path, "tests", "testthat"), recursive = TRUE)
file.copy(system.file("templates", "testthat.R", package = "fakemake"),
          file.path(pkg_path, "tests"))
file.copy(system.file("templates", "test-throw.R", package = "fakemake"),
          file.path(pkg_path, "tests", "testthat"))
withr::with_dir(pkg_path, print(fakemake::make("covr", ml)))
```
This looks better:
``` {r}
file.show(file.path(pkg_path, "log", "covr.Rout"), pager = "cat")
```

# References
