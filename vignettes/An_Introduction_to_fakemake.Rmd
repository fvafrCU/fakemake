---
title: "An Introduction to *fakemake*"
author: "Andreas Dominik Cullmann"
date: 2017-11-03, 15:02:11
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{An Introduction to fakemake }
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
references:
- id: powers2002
  title: Unix Power Tools
  author:
  - family: Powers
    given: Shelley
  - family: Peek
    given: Jerry
  - family: "O'Reilly"
    given: Tim
  - family: Loudikes
    given: Mike
  ISBN: 0-596-00330-7
  publisher: "O'Reilly & Associates"
  type: book
  issued:
    year: 2002
---

# Mock the Unix Make Utility
There are 
[many](https://en.wikipedia.org/wiki/List_of_build_automation_software)
[build systems](https://en.wikipedia.org/wiki/Build_automation), 
and more uses for build systems [see @powers2002, sections 11.10 and 11.11].

I have been using the 
[unix make utility](https://en.wikipedia.org/wiki/Make_(software)) when 
developing R packages since 2012. But sometimes I get caught on a machine where 
*make* is not available and where I am not entitled to install it. 
This is why I wrote *fakemake*: to build an R package conditionally on the 
modification times of (file) dependencies without having to rely on external 
software. 
If you have any proper build system at hand: stick to it, do not use *fakemake*.

# Makelists
A makelist is the *fakemake*`s representation of a Makefile. 
It's just a list of lists. 
Look at the minimal makelist provided with *fakemake*: 
```{r}
str(fakemake::provide_make_list("minimal", clean_sink = TRUE))
```
Each sublist has several items: as least a *target* and either *code* or 
*prerequisites*, possibly both.
Describe names, mention sink, phony and alias.
Minimum: a target and either code or prerequisites.


# A Minimal Example
Suppose we would have a minimal makelist:
```{r}
ml <- fakemake::provide_make_list("minimal")
```
Now we would use **R**`s temporary directory to build the first target in this 
makelist:

```{r}
withr::with_dir(tempdir(), print(fakemake::make(ml[[1]][["target"]], ml)))
```
We can see the files created:
```{r}
show_file_mtime <- function(files = list.files(tempdir(), full.names = TRUE, 
                                               pattern = "^.*\\.Rout")) {
    return(file.info(files)["mtime"])
}
show_file_mtime()
```
If we wait for a second and rerun the build process, we get:

```{r}
# ensure the modification time would change if the files were recreated
Sys.sleep(1)
withr::with_dir(tempdir(), print(fakemake::make(ml[[1]][["target"]], ml)))
show_file_mtime()
```
Nothing changed. Good.
Now, we change one file down the build path:

```{r}
fakemake::touch(file.path(tempdir(), "b1.Rout"))
withr::with_dir(tempdir(), print(fakemake::make(ml[[1]][["target"]], ml)))
show_file_mtime()
```

Since a1.Rout depends on b1.Rout and all.Rout depends on a1.Rout, these targets
get rebuilt while a2.Rout stays untouched.
# References
